<html>
    <body>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
        <script>
            //创建一个 Vue 实例
            var vm = new Vue({
                //选项
            })
        </script><div id="app">
            <p>{{foo}}</p>
            <!-- 这里的 `foo` 不会更新 -->
            <button v-on:click = "foo = 'baz'">Change it </button>
        </div>
        <script>
            //数据与方法


            //数据对象
            var data = {a:1}

            //该对象被加入到一个 Vue 实例中
            var vm = new Vue({
                data:data
            })

            //获得这个实例上的属性
            //返回源数据中对应的字段
            vm.a == data.a //=>true

            //设置属性也会影响到原始数据
            vm.a= 2
            data.a //=>2 

            // 反之亦然
            data.a = 3
            vm.a //=>3

            //当这些数据改变时，视图会进行重渲染。
            // 只有当实例被创建是就已经存在于 data 中的属性才是 响应式 的
            vm.b = 'hi'
            
            
            // 唯一的例外是使用 Object.freeze() .这会阻止修改现有的属性，也意味着响应系统无法再追踪变化
            var obj ={
                foo:'bar'
            }

            Object.freeze(obj)

            new Vue({
                el:"#app",
                data:obj
            })
        </script>
        <script>
            var data = {a:1}
            var vm = new Vue({
                el:"#example",
                data:data
            })

            vm.$data === data //=>true
            vm.$el === document.getElementById('example') //=>true

            //$watch 是一个实例方法
            vm.$watch('a',function (newValue,oldValue){
                //这个回调将在 `vm.a` 改变后调用
            })
        </script>
        <script>
            //实现生命周期的钩子

            //如 created 钩子可以用来在一个实例被创建之后执行代码
            new Vue({
                data:{
                    a:1
                },
                created:function(){
                    //`this` 指向 vm 实例
                    console.log('a is :' + true.a)
                }
            })
            //=> "a is : 1"
        </script>
    </body>
</html>