<html>
    <body>
        <p>JS中在执行的时候把js代码分成了同步执行任务和异步执行任务</p>
        <p>同步处理：当前执行任务是按照顺序依次处理，当前这件事没有彻底做完，下一件事是执行不了的</p>
        <p>异步处理：当前这件事需要过一会再做或者执行时机不正确（定时器是过一会才执行，js中的事件是执行时机不确定），此时浏览器不是等这件事做完，而是继续执行后面的任务，<br>
        当后面的任务完成后，再去把没做完的事情做完</p>

        <p>JS中的常见异步执行：</p>
        <p>1 所有的事件函数都是异步执行的 box.onclick = function ……</p>
        <p>2 所有的定时器的回调函数都是异步执行 setTimeout(callback,time)</p>
        <p>3 AJAX中的异步情形</p>
        <p>4 回调函数也是异步编程</p>
        <script>
            //异步编程：编写异步执行的程序称为异步程序，js的异步处理机制是 js 这门语言最大的特殊
            let n =0;
            setTimeout(()=>{
                n++;
                console.log('abc')
            },3000);
            console.log(n);//?这里输出 n 的值是多少? 是0
        </script>
        <p>浏览器是如何实现异机制的</p>
        <p>JS是单线程的，它一次只能干一件事。而能实现异步，是依赖于浏览器的任务队列实现的。浏览器中有两个任务队列：主任务列和等待任务队列</p>
        <p> 主任务队列：主任务队列的都是当前需要同步执行的同步任务</p>
        <p> 等待仍无队列：把不需要立刻执行的异步任务都放到等待任务队列中</p>
        <p>当主任务队列中的任务执行结束后，就去执行等待任务队列中的任务，看看哪些任务该执行了，如果某个任务该执行了 <br>
        那么浏览器就会执行它。如果有多个都达到执行条件了，谁先到的就执行谁</p>
        <p>注意：如果主任务队列中的代码执行不完，那么等待任务队列中的任务是不会执行的</p>
        <script>
            setTimeout(()=>console.log('结束了'),1000);

            // while(true){
            //     //while 循环是个同步任务
            // }

            //死循环就相当于主任务队列没有执行完，所以即便定时器到了时间也没办法执行
        </script>
        <ol>
            <li>定时器的事件写0也不是同步任务，只要是定时器就是异步任务，也需要等到所有的同步任务都执行完再执行等待任务你队列中的任务。<br>
            因此即便写0，浏览器也存在等待和反应时间，这个时间依赖于浏览器版本以及操作系统和硬件，<br>
            当设置的最小时间小于这个时间时，定时器使用的就是自身最小的反应和等待时间</li>
            <li>当主任务队列自上而下的执行时，如果遇到一个异步操作，浏览器不会等着这个异步的操作，而是先把这个异步任务添加到等待任务队列中排队</li>
            <li>当主任务队列中的任务执行完成后，才会去等待任务队列中（如果主任务队列执行不完，不管等待任务队列中的任务时候到达时间，都不会执行）；</li>
            <li>等待任务队列中谁先达到条件了（如果有多个都达到条件了，谁先到的就先处理谁），就把这个任务放到主任务队列中执行，执行完再去等待任务找</li>

        </ol>
    </body>
</html>