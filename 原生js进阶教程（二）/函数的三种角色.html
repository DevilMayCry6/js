<html>
    <body>
        <h4>函数的三种角色：</h4>
        <p>1 作为一个普通函数执行（形参、实参、返回值）</p>
        <p>2 作为一个类（new Fn 构造函数执行）</p>
        <p>函数也是一个普通对象（通过 .属性名 或者 ['属性名']获取私有属性）</p>
        <script>
            //1 普通函数
            function sum(a,b){
                var x = 1;
                var y = 12;
                var z = 121;
                return a+b+x+y+z;
            }
            var result = sum(1,3);
            console.log(result);
        </script>
        <h4>普通函数执行的过程：</h4>
        <p>1 开辟一个新的作用域</p>
        <p>2 形参赋值</p>
        <p>3 变量提升</p>
        <p>4 函数体从上到下执行</p>
        <p>5 销毁作用域</p>
        

        <script>
            // 2 构造函数（类）：
            //2.1 每个构造函数都有一个 prototype 属性，它的值是一个对象，用来存放当前类型的公有的属性和方法
            //2.2 必须通过new 操作符调用函数才能返回一个实例对象

            function Teacher(n,a,s,f){
                //通过 this.xxx = xxx 给实例对象添加私有属性
                this.name = n;
                this.age = a;
                this.subject = s;
                this.from = f;
            }
            
            //在原型上增加的方法都是这个类型公有的属性和方法
            Teacher.prototype.teach = function(){
                console.log(`${this.name} 老师讲 ${this.subject} 课程`)
            }
            let t = new Teacher('张',18,'js',"JS")

            //new 执行构造函数
            /*1 新开辟一个作用域
            2 形参赋值
            3 变量提升
            4 隐式创建一个当前类的实例对象，并且把构造函数中的 this 指向当前实例
            5 执行构造函数中的代码
            6 隐式返回实例对象，相当于 return this 
            7 销毁作用域 */

            console.log(t,name);
            console.log(t.age);
            t.teach(); //调用 Teacher 的公有方法

            // 3 作为一个普通对象（所有引用数据类型都是一个Object的一个实例）;
            function fe(a,b){
                console.log("I am excellent FE cultivated by JS")
            }
            fe(1,2);

            console.dir(fe); //{name:"fe",length:形参个数。。。}

            console.log(fe.length);// 2 形参个数
            console.log(fe.name);// 函数名

            /* 把函数当做普通对象使用，就像操作普通对象一样操作对象;
            通过这样的方式添加给函数（普通函数、构造函数）的属性或者方法称为静态属性或方法 */

            fe.age = 10;
            fe.title = "hello";
            fe.greeting = function (){
                console.log('hello world')
            };
            console.log(fe.age);
            console.log(fe.title);

            let f1 = new fe();
            console.log(f1.age);// undefined
            console.log(f1.title); //undefined
            console.log(f1);
            console.log(fe.prototype);
            console.dir(fe);

            /* 注意：通过 函数名.xxx = xxx 添加的属性都是这个函数的私有属性。
            如果这个函数被当做构造函数使用（用 new 调用）时，
            这些属性既不是实例的属性也不是实例的公有属性，只能通过 函数名.xxx 的方式获取; */


            // Array.isArray()
            // 是数组 Array 的静态方法，只能通过 Array 自己调用;
            // Array.isArray()检测一个值是否是一个数组,如果是返回 true ,不是就返回 fasle
            
            console.log(Array.isArray([]));//true
            console.log(Array.isArray(1));//false
        </script>
    </body>
</html>